Welcome back. In this lesson, it's time to use some of the theory that you've learned about on encryption fundamentals and KMS and talk more specifically about encryption within S3. So, let's jump in and get started. Now, before we start, there's one common misconception which I want to fix right away, and that is that buckets themselves aren't encrypted. The objects inside buckets can be encrypted. You don't define encryption at the bucket level. There's something called bucket default encryption, but that's different and I'll cover that later in this lesson. For now, just understand that you define encryption at an object level and each object inside a bucket could be using different encryption settings. Now, there are two main methods of encryption that S3 is capable of supporting. We've got client side encryption and serverside encryption. And both of these refer to encryption at rest. So, the method of determining how objects are encrypted when they're persistently stored on disk. It doesn't refer to encryption in transit, which is a completely separate thing inside S3. So, visually, this is how a transaction between a group of users or an application and S3 looks like. We've got the users or the application on the left uploading data to an S3 endpoint for a specific bucket which gets stored on S3's base storage hardware. That's on the right. I want to quickly illustrate the difference between client side and serverside encryption. So on the top we have client side encryption and on the bottom we've got serverside encryption. Now both of these methods use encryption in transit between the user side and S3. This is an encrypted tunnel which means that you can't see the raw data inside that tunnel to the outside world. It's completely scrambled. So it's important that you understand that when We're talking about S3 object encryption. We're focused on encryption at rest. How the object is persistently stored. We're not talking about encryption in transit, which comes as standard with S3. The difference between clientside encryption and serverside encryption is pretty simple to understand when you see it visually. With clientside encryption, the objects being uploaded are encrypted by the client before they ever leave. And this means that the data is cipher text the entire time. From AWS's perspective, the data is received in a scrambled form and stored in a scrambled form. AWS would have no opportunity to see the data in its plain text form at any point. So that's important to understand. Clientside encryption happens on the client side before it even leaves for transit to S3. With server side encryption, it'slight slightly different here. Even though the data is encrypted in transit using HTTPS, the objects themselves aren't initially encrypted. Meaning that inside the tunnel, the data is in its original form. Let's assume for this example, it's animal images taken by the animals for life field workers. Once this data, which is still in its plain text form, it is encrypted in transit, but when it reaches the S3 endpoint, it's still in plain text. Once the data hits it's S3 then it's encrypted by the S3 infrastructure which is why it's referred to as serverside encryption. The highle difference is that with clientside encryption everything is yours to control. You take on all the risk and you control everything which is both good and bad. You take the original data and you are the only one who ever sees the plain text version of this data using client side encryption. You generate a key, you hold that key, you manage that key. You are responsible for recording which key is for what file. You perform the encryption process before it's uploaded to S3. And this consumes CPU capacity. You just use S3 for storage, nothing else. So you own and control the keys, the process, and any tooling. So if your organization needs all of these, then you need to utilize clientside encryption. And essentially, this doesn't use S3 for any part of this encryption process with service. side encryption, you allow S3 to handle some or all of those processes. But that means there are parts that you need to trust S3 with. So let's break apart the serverside encryption category and take a look at exactly how it's architected. There are three types of serverside encryption available for S3 objects. And each of these is a trade-off between the usual things. So trust, overhead, cost, resource consumption, and much more. Let's quickly step through them and look at how they work. Now the first is SSE- C and this is serverside encryption with customerp provided keys. The second is SSE- S3 which is serverside encryption with Amazon S3 managed keys. And the last one is an enhancement on SSE S3 which is SSE KMS. So this is serverside encryption with KMS keys stored within the A WS key management service known as KMS. Now there are two components to serverside encryption. The first is the actual encryption and decryption process itself. So taking plain text, a key and an algorithm and generating cipher text and the reverse which is taking that cipher text and the key and using an algorithm to reproduce the plain text. So one half of the process that serverside encryption can do is the actual encryption operations. And the second part is the generation and the management of the cryptographic keys. Now these three methods they handle each of these two things differently. So let's take a look at how with SSE C the customer is responsible for the encryption keys that are used for encryption and decryption and the S3 service manages the actual encryption and decryption process. So the first major change between clientside encryption And this is that the S3 service is handling the cryptographic operations. Now, this might sound like a small thing, but if you're dealing with millions of objects and potentially a high number of transactions, then the CPU capacity required to do this can really quickly add up. So, by giving it to S3, you're essentially offloading the CPU requirements for this process. But you still need to generate and manage the key or the keys. that this S3 encryption process will use. So when you're utilizing this method, when you put an object into S3, you're required to provide the object and a key. So the object at this point is plain text and you need to provide an encryption key that S3 will utilize. Now remember this data is encrypted in transit by HTTPS. So even though you're supplying the S3 endpoint with this plain text object to the outside world, it's still will appear to be scrambled but S3 do see the original object that you're uploading. So when this object and the encryption key arrive at the S3 endpoint so you need to provide both but when they arrive the object is encrypted using this key and at the same time a hash of the key is taken and attached to the object. Now this hash is one way it can't be used to generate a new key but if a key is provided during decryption the hash can identify if the specific key is the one that was used or not to encrypt that object. So it's essentially a safety feature. It makes sure that when you're decryting the thing, you need to provide the same key. So the object is encrypted with the key that you supply. A hash is taken of the key and then the key is discarded. So the object and this one-way hash are stored persistently on storage. So remember S3 don't have have the original key used to encrypt this object. At this stage, it's discarded as soon as the encryption process has completed. To decrypt the object, you need to provide S3 with a request. So, you need to tell it which object you want to decrypt and you need to provide it with the key that was used to encrypt it. If the key that you supply is correct, and the way that S3 determines this is by comparing the hash, then S3 decrypts the object, discards the key, and returns returns to you the plain text unencrypted object. Now this method is interesting. You still need to manage your encryption keys which is a cost and an amount of effort but you also retain control of that process which is good in some regulationheavy environments. You save on the CPU requirements of the encryption and decryption process meaning that smaller lower power devices don't need to consume resources encrypting or decryptting data. But you do need to trust that S3 will discard the keys that you send them to encrypt and decrypt. But there are audits which prove what AWS do and when. So you can always consult these. So this is SSE- C and it gets used when you need to retain key management, but you don't need to retain the overhead of encryption and decryption. Okay, so this is the end of part one of this lesson. It was getting a little bit on the long side and so I wanted to add a break. It's an opportunity just to take a rest. or grab a coffee. Part two will be continuing immediately from the end of part one. So, go ahead, complete the video and when you're ready, join me in part two.

