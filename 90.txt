Welcome back. This is part two of this lesson. We're going to continue immediately from the end of part one. So, let's get started. The second method that I want to describe is SSE- S3. With this method, AWS handles both the encryption and decryption processes as well as the key generation and management. With this method, when you put an object into S3, you just provide the plain text data, the unencrypted object. When using this encryption method, S3 the service creates a root key to use for the encryption process. So that's all the encryption process, not just this one particular object. You don't get to influence this. You can't change any options on this root key, nor do you get to pick it. It's handled end to end by S3. From your perspective, it isn't visible anywhere in the UI, and it's rotated internally by S3 out of your visibility and control. Now, when an object is uploaded to S3 using SSE- S3 encryption, it's actually encrypted by a key that's unique for every single object. So, the way that this works is that S3 generates a key specifically for this one object. So, it's a key specifically designed to encrypt this one object and then it uses that key to encrypt that plain text object. Then the root key key is used to encrypt that unique key and the original unencrypted version of that key is discarded. What we are left with is a cipher text or an encrypted object and a cipher text or an encrypted key. Both of which are stored persistently on the S3 storage system with each other. So these are stored side by side. With this method AWS take over the encryption process. So just as with SSE hyphen C AWS handle the encryption and decryption processes but they also manage the keys on your behalf which means less admin overhead. The flip side is that you have very little control over how these keys are used. The root key is outside of your control and the individual keys used to encrypt and decrypt the objects are also outside of your control. For most situations though SSE- S3 is the default type of encryption which makes sense. uses a strong algorithm AES 256. The data is encrypted at rest and the customer doesn't have any admin overhead to worry about. But it does present three significant problems. If you're in a regulatory environment where you need to control the keys that are used and control access to those keys, then this isn't suitable. If you need to be able to control the rotation of key material, again, this isn't suitable. If you need roll separation, this isn't suitable. able. Now what I mean by role separation is that a full S3 administrator, so somebody who has full S3 permissions to configure the bucket to manage the objects, he or she can also decrypt and view data. And in certain industry areas such as financial and medical, you may not be allowed that. You may have certain groups within a business who need to be able to access the actual object data, but they can't. manage permissions and you have another group, a CIS admin group who need to manage the infrastructure but legally can't have any access to the data. This is called ro separation. Different roles each of which have a different set of permissions. Now with sec this is not easy to accomplish because a full S3 administrator by definition would have full access to decrypt and open objects. The person or the group would not be a full S3 administrator if they didn't have this access. And that's where the final type of serverside encryption comes in really handy. And the name of this type is SSE- KMS. This method is much like SSE- S3 where AWS handle both the keys and the encryption process. But unlike SSE- S3 where S3 handles the root key used to encrypt the object encryption keys, With this method, it's handled by a separate service. It's handled by the key management service or KMS. Now, this seems on the surface like a small change, but it's actually really significant. When you upload an object and pick SSE- KMS for the first time, S3 liazes with KMS and creates an AWS managed KMS key. This is the default key which gets used when using SSE- KMS in future. This means that every time an object is uploaded, S3 uses a dedicated key to encrypt that object. And that key is a data encryption key which KMS generates using the KMS key. S3 is provided with a plain text version of the data encryption key as well as an encrypted one. The plain text one that's used to encrypt the object and then it's discarded. The encrypted data encryption key is stored along with the encrypted object. So if you remember in the KMS lesson where I spoke about how data encryption keys can be used to encrypt data more than 4 kilobytes in size. Well, this is the first service which we've talked about which uses this architecture. Every object which is uploaded and encrypted with SSE KMS requires a KMS key. This KMS key is used to generate one unique data encryption key for every object that's encrypted using SSE-KMS. Now, when uploading an object using this encryption type, you don't have to use the default KMS key that S3 creates. You can pick to use your own customer-man-managed KMS key. And that means you can control the permissions on it and the rotation of the key material. So, in regulated industries, this alone is often enough reason to consider SSE-KMS because it gives fine drained control over the KMS key being used and its rotation and you can also have logging and auditing on the KMS key itself. With Cloud Trail, you'll also be able to see any calls made against this key. But probably the best benefit provided by SSE KMS is the RO separation. To decrypt any objects in a bucket where those objects have been encrypted with SSE KMS, you need access to the KMS key that was used. to generate the unique key that encrypted them. The KMS key is used to decrypt the data encryption key for the object and then that decrypted data encryption key decrypts the object itself. If you don't have access to KMS, you can't access the object. What this means is if we had an S3 administrator, let's call him Phil. Well, if Phil wasn't the most rule following type of person and he had full administration rights of S3, then he can perform perform any operations on S3. But because Phil has no permissions on the KMS key that's been used to encrypt these objects, he can't read any of the objects inside the bucket that have been encrypted using that KMS key. The permissions prevent him from running the decryption operation. So SSC KMS gives you that role separation. It allows for teams of people to be S3 administrators without having the ability to decrypt things. So in summary, with client side encryption, you handle both the key management and the encryption processes. So use this method if you absolutely need to control both of these or you don't trust AWS and their regular audits. It uses more resources to manage keys and actually perform the encryption processes at scale, but it's definitely the method that gives you the most control. With SSC C, you manage the keys. You can use the same key for everything, which is insecure, or you could use individual keys. The choice is yours, but you manage the keys and S3 handles the overhead for encryption and decryption. With SSE- S3, this uses AES 256. I mention this because it's often the way exam questions test your knowledge. So, AES 256 is the encryption algorithm and S3 handles the keys and the encryption processes when you utilize SSE- S3. It probably should be your default if you want encryption. But you don't have any real control over keys, their permissions or their rotation. SSE- KMS uses KMS and KMS keys. You can control key rotation. You can control key permissions. It's otherwise similar to SSE- S3, but it allows RO separation. So, use this if your business has fairly rigid groups of people and compartmentalized sets of security. You can have S3 full administrators who won't have any access to decrypt and access data. One more thing before we finish, and that's default bucket encryption. When you're uploading objects to S3, you're actually utilizing the put object operation. As part of this operation, you can specify a specific header, which is X - AMZ server- side encryption. And this is how you direct AWS to use serverside encryption. Obviously, if you're using the console UI or the command line interface, then it's handled in a nice userfriendly way, but this is actually how it works behind the scenes. If you don't specify this header, then objects will not use encryption. If you do specify this header, if you use AES 256, then this utilizes SSE- S3. If you specify AWS colon KMS, then SSE- KMS is utilized. This is all done on a per object basis. But there is a feature which can be set on a bucket which sets the default the thing which is applied when you don't specify the above header on a per object basis. So let's say that we set the default to be AES 256 then sse- s3 would be used when you don't set something at an object level. This is the key thing. The bucket default is just that a default. It applies only when you don't specify anything explicitly on a bucket. If you do, that takes priority. It's also not a limit or a restriction. So, it doesn't require you to use a specific type of encryption that you set as the default. You can use a bucket policy to restrict the type of encryption that's possible on a bucket, though, and we'll talk about that later. But at this point, that is everything I wanted to cover in this video. So, go ahead and complete the video, and when you're ready, I look forward to you joining. me in the next.

