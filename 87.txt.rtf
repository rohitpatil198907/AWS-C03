{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red24\green24\blue24;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c12157\c12157\c12157;\cssrgb\c100000\c100000\c100000;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Welcome to this video where I'm going to be talking about the key management service known as KMS. Now, this product is used by many other services within AWS when they use encryption. So, don't be surprised if you're watching this video in what seems like a pretty random place within the course. With that being said, let's jump in and get started. Now, KMS isn't all that complex as a product. Once you understand it, it's pretty simple. But because of how much it's used by other AWS products and services. It's essential that you do understand it for all of the AWS exams. Now, KMS is a regional and public service. Every region is isolated when using KMS. Think of it as a separate product. Now, KMS is capable of some multi-reion features, but I'll be covering those in a separate dedicated video. It's a public service, which means it occupies the AWS public zone and can can be connected to from anywhere with access to this zone. Like any other AWS service though, you will need permissions to access it. Now KMS, as the name suggests, manages keys. Specifically, it lets you create, store, and manage cryptographic keys. These are keys which can be used to convert plain text to cipher text and vice versa. Now, KMS is capable of handling both symmetric and asymmetric keys. And at this point, you should understand what that means. Where symmetric keys are used, where public asymmetric are used as well as private asymmetric. Just know that KMS is capable of operating with all of these different key architectures. Now, KMS is also capable of performing cryptographic operations which includes but is not limited to encryption and decryption operations and I'll be talking more about this later in this video. Now, one of the foundational things to understand about KMS is that cryptographic keys never leave the product. KMS can create keys, keys can be imported, it manages keys, it can use these keys to perform operations, but the keys themselves are locked inside the product. Its primary function is to ensure the keys never leave and are held securely within the service. Now, KMS also provides a FIPS 140-2 compliant service. This is a US security standard, but try to memorize this. It's FIPS 140-2 level two to be specific. Again, the level two part matters. It's often a key point of distinction between using KMS versus using something like cloud HSM, which I'll be covering in detail elsewhere. Now, some of KMS's features have achieved level three compliance, but overall it's level two. Again, Please do your best to remember this. It will come in handy for most of the AWS exams. Now, before we continue, since this is an introduction video, unless I state otherwise, assume that I'm talking about symmetric keys when I mention keys within this video. I'm going to be covering the advanced functionality of KMS in other videos, including asymmetric keys. But for this one, I'm mainly focusing on its architecture and highlevel functions. So just assume I'm talking about symmetric keys from now on unless I indicate otherwise. Now the main type of key that KMS manages are known logically enough as KMS keys. You might see these referred to as CMKs or customer master keys, but that naming scheme has been superseded. So they're now called KMS keys. These KMS keys are used by KMS within cryptographic operations. You can use them, applications can use them, and other AWS services can use them. Now, they're logical. Think of them as a container for the actual physical key material. And this is the data that really makes up the key. So, a KMS key contains a key ID, a creation date, a key policy, which is a resource policy, a description, and a state of the key. Every KMS key is backed by physical key material. It's this data which is held by KMS. And it's this material which is actually used to encrypt and decrypt things that you give to KMS. The physical key material can be generated by KMS or imported into KMS. And this material contained inside a KMS key can be used to directly encrypt or decrypt data up to 4 KB in size. Now this might sound like a pretty serious limitation. KMS keys are generally only used to work on small bits of data or to generate other keys. And I'll be covering this at a high level later in this video. Let's look visually at how KMS works so far. So this is KMS and this is Ashley. Ashley's first interaction with KMS after picking a region is to create a KMS key. A KMS key is created with physical backing material and this key is stored within KMS in an encrypted form. Nothing in KMS is ever stored in plain text form persistently. It might exist in memory in plain text form, but on disk it's encrypted. Now, Ashley's next interaction with KMS might be to request that some data is encrypted. To do this, she makes an encrypt call to KMS specifying the key to use and providing some data to encrypt. KMS accepts the data and assuming Ashley has permissions to use the key, key. It decrypts the KMS key, then uses this key to encrypt the plain text data that Ashley supplied and then returns that data to Ashley. Notice how KMS is performing the cryptographic operations. Ashley is just providing data to KMS together with instructions and it's handling the operations internally. Logically, at some point in the future, Ashley will want to decrypt this same data. So, she calls a decry operation and she includes the data she wants to decrypt along with this operation. KMS doesn't need to be told which KMS key to use for the decrypt operation. That information is encoded into the cipher text of the data which Ashley wants to decrypt. The permissions to decrypt are separate from the permissions to encrypt and are also separate from permissions which allow the generation of keys. But assuming Ashley has the required permissions for a decrypt operation, using using this specific KMS key. KMS decrypts the key and uses this to decrypt the cipher text provided by Ashley and returns this data back to Ashley in plain text form. Now again I want to stress at no point during this entire operation do the KMS keys leave the KMS product. At no point are the keys stored on the disk in plain text form and at each step Ashley needs permissions to perform the operations. And each operation is different. KMS is very granular with permissions. You need individual permissions for various operations including encrypt and decrypt. And you need permissions on given KMS keys in order to use those keys. Ashley could have permissions to generate keys and to use keys to encrypt and decrypt. Or she could have just one of those permissions. She might have permissions to encrypt data but not decrypt it. Or She might have permissions to manage KMS, creating keys and setting permissions, but not permissions to use keys to encrypt or decrypt data. And this process is called RO separation. Now, I mentioned at the start of this lesson that a KMS key can only operate cryptographically on data which is a maximum of 4 KB in size. Now, that's true. So, let's look at how KMS gets around this. Data encryption keys, also known as DEX, or DEKs are another type of key which KMS can generate. They're generated using a KMS key using the generate data key operation. This generates a data encryption key which can be used to encrypt and decrypt data which is more than 4 KB in size. Data encryption keys are linked to the KMS key which created them. So KMS can tell that a specific data encryption key was created. using a specific KMS key. But, and this is pretty much the most important thing about KMS and data encryption keys, KMS doesn't store the data encryption key in any way. It provides it to you or the service using KMS and then it discards it. The reason it discards it is that KMS doesn't actually do the encryption or decryption of data using data encryption keys. You do or the service using KMS performs those operations. So let's look at how this works. When a data encryption key is generated, KMS provides you with two versions of that data encryption key. First, a plain text version of that key, something which can be used immediately to perform cryptographic operations and second a cipher text or encrypted version of that same data encryption key. The data encryption key is encrypted using the KMS key that generated it and in future this encrypted data encryption key can be given back to KMS for it to be decrypted. Now the architecture is that you would generate a data encryption key immediately before you wanted to encrypt something. You would encrypt the data using the plain text version of the data encryption key and then once finished with that process discard the plain text version of that data encryption key. That would leave you with the encrypted data and You would then store the encrypted data encryption key along with that encrypted data. Now, a few key things about this architecture. KMS doesn't actually do the encryption or decryption on data larger than 4KB using data encryption keys. You do or the service using KMS does. KMS doesn't track the usage of data encryption keys. That's also you or the service using KMS. Now, you could use the same data encryption key to encrypt a 100 or a million files or you could request a new data encryption key for each of those million files. How you decide to do this is based on your exact requirements and of course AWS services will make this choice based on their requirements. By storing the encrypted data encryption key on disk with the encrypted data, you always have the correct data encryption key to use, but both the deck and the data are encrypted. So administration is easy and security is maintained. Now decryting that data is simple. You pass the encrypted data encryption key back to KMS and ask for it to decrypt it using the same KMS key used to generate it. Then you use the decrypted data encryption key that KMS gives you back and decrypt the data with it and then you discard the decrypted data encryption key. Services such as S3 when using KMS generate a data encryption key for every single object. They encrypt the object and then discard the plain text version. As we move through the course, I'll be talking in detail about how those services integrate with KMS for encryption services. But before we finish up with this lesson, there are a few key concepts which I want to discuss. The one thing which is really important to grasp with KMS is that by default, KMS keys are stored within the KMS service in that specific region. They never leave the region and they never leave the KMS service. You cannot extract a KMS key. Any interactions with a KMS key are done using the APIs available from KMS. Now, this is the default, but KMS does support multi- region keys where keys are replicated to other AWS regions, but but I'll be covering that in a dedicated video if required for the course that you're studying within KMS as a product. keys are either AWSowned or customerowned. We're going to be dealing mainly with customerowned keys. AWSowned keys are a collection of KMS keys that an AWS service owns and manages for use in multiple AWS accounts. They operate in the background and you largely don't need to worry about them. If applicable for the course that you're studying, I'll have a separate video on this. If not, don't worry. It's unimportant. Now, when dealing with customer their own keys. There are two types, AWS managed and customer managed. And I'll be covering the specifics of these in a dedicated video. AWS managed keys are created automatically by AWS when you use a service such as S3, which integrates with KMS. Customer managed keys are created explicitly by the customer to use directly in an application or within an AWS service. Customer managed keys are more configurable. For example, you can edit the key policy, which means you could allow cross account access so that other AWS accounts can use your keys. AWS managed keys can't really be customized in this way. Both types of keys support rotation. Rotation is where physical backing material, so the data used to actually do cryptographic operations is changed. With AWS managed keys, this can't be disabled. It's set to rotate a approximately once per year. With customer managed keys, rotation is optional. It's enabled by default and happens approximately once every year. A KMS key contains the backing key, the physical key material, and all previous backing keys caused by rotation. It means that as a key is rotated, data encrypted with old versions can still be decrypted. Now, you can create aliases, which are shortcuts to keys. So, you might have an alias called my app one which points at a specific KMS key. That way KMS keys can be changed if needed. But be aware the aliases are also per region. You can create my app one in all regions but in each region it will point at a different key. Neither aliases or keys are global by default. Okay. To finish up this KMS 101 lesson, I want to talk at high level about permissions on KMS keys. Permissions on keys are controlled in a few ways. KMS is slightly different than other AWS services that you come across in terms of how keys are handled. Many services will always trust the account that they're contained in. Meaning, if you grant access via an identity policy, that access will be allowed unless there's an explicit deny. KMS is different. This account trust is explicitly added on a key policy or not. The starting point for KMS security is The key policy. This key policy is a type of resource policy like a bucket policy only on a key. Every KMS key has one. And for customer managed keys, you can change it. To reiterate this, the reason the key policy is so important is that unlike other AWS services, KMS has to explicitly be told that keys trust the AWS account that they're contained within. And this is what a key policy might look like. It means that the key will allow the account 1111 2222 3333 to manage it. This trust isn't automatic, so be careful when updating it. You always need this type of key policy in place if you want to be able to grant access to a key using identity policies. Without it, the key doesn't trust the AWS account. And this means that you would need to explicitly add any permissions on the key policy itself. Generally, KMS is managed using this combination of key policies, trusting the account and then using identity policies to let IM users interact with the key. But in high security environments, you might want to remove this account trust and insist on any key permissions being added inside the key policy. And a typical I am permissions policy for KMS might look something like this, which gives the holder of the policy the rights to use this key to encrypt or decrypt data. Inside KMS, permissions are very granular and can be split based on function. You can be granted rights to create keys and manage keys, but not have permissions to perform cryptographic operations like encrypt or decrypt. This way, your product administrators aren't given rights to access data encrypted by KMS, which is a common requirement of many higher security environments. Now, there's another way to interact with KMS using grants, but I'll be covering this elsewhere in another video if needed. So, that's everything I wanted to cover in this KMS introduction video. This video is going to form the foundation for others in this series. Depending on the topic that you're studying, there might be no more videos or many more videos. Don't be worried in either case. Now, at this point, that's everything I wanted to talk about though about KMS at this introductory level. Go ahead and complete the video and when you're ready, I look forward to you joining me in the next}